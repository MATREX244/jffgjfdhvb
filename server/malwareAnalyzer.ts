import crypto from "crypto";

/**
 * Malware threat types
 */
export type ThreatType = "virus" | "spyware" | "rat" | "trojan" | "ransomware" | "worm" | "backdoor" | "adware" | "rootkit" | "keylogger";

/**
 * Threat level classification
 */
export type ThreatLevel = "clean" | "suspicious" | "malicious" | "critical";

/**
 * Detected threat information
 */
export interface DetectedThreat {
  type: ThreatType;
  confidence: number; // 0-100
  description: string;
  location?: string;
}

/**
 * Suspicious pattern found in binary
 */
export interface SuspiciousPattern {
  name: string;
  description: string;
  severity: "low" | "medium" | "high" | "critical";
  indicator: string;
  confidence: number; // 0-100
}

/**
 * Behavioral indicator
 */
export interface BehaviorIndicator {
  behavior: string;
  description: string;
  severity: "low" | "medium" | "high" | "critical";
  confidence: number; // 0-100
}

/**
 * Analysis result from malware analyzer
 */
export interface MalwareAnalysisResult {
  fileHash: string;
  fileSize: number;
  suspiciousPatterns: SuspiciousPattern[];
  detectedThreats: DetectedThreat[];
  behaviorAnalysis: BehaviorIndicator[];
  threatLevel: ThreatLevel;
  riskScore: number; // 0-100
  summary: string;
}

/**
 * Malware signature database - common patterns found in malware
 */
const MALWARE_SIGNATURES: Record<string, { type: ThreatType; severity: "low" | "medium" | "high" | "critical"; description: string }> = {
  // Common malware strings and patterns
  "CreateRemoteThread": { type: "rat", severity: "critical", description: "Remote thread injection - common in RATs" },
  "WinExec": { type: "trojan", severity: "high", description: "Hidden process execution" },
  "SetWindowsHookEx": { type: "keylogger", severity: "high", description: "Keyboard hook - keylogger indicator" },
  "GetAsyncKeyState": { type: "keylogger", severity: "high", description: "Keyboard state monitoring - keylogger" },
  "InternetOpen": { type: "spyware", severity: "high", description: "Network communication - data exfiltration" },
  "URLDownloadToFile": { type: "trojan", severity: "high", description: "File download capability" },
  "RegOpenKey": { type: "ransomware", severity: "medium", description: "Registry modification" },
  "DeleteFile": { type: "ransomware", severity: "medium", description: "File deletion capability" },
  "CryptEncrypt": { type: "ransomware", severity: "high", description: "Encryption function - ransomware" },
  "ShellExecute": { type: "trojan", severity: "high", description: "Command execution" },
  "CreateProcess": { type: "worm", severity: "high", description: "Process creation" },
  "WriteFile": { type: "virus", severity: "medium", description: "File writing capability" },
  "FindFirstFile": { type: "virus", severity: "low", description: "File enumeration" },
  "GetSystemDirectory": { type: "backdoor", severity: "high", description: "System directory access" },
  "LoadLibrary": { type: "trojan", severity: "medium", description: "Dynamic library loading" },
  "GetProcAddress": { type: "trojan", severity: "medium", description: "Function resolution" },
  "VirtualAlloc": { type: "worm", severity: "high", description: "Memory allocation for code injection" },
  "SetFilePointer": { type: "virus", severity: "low", description: "File manipulation" },
  "ReadFile": { type: "spyware", severity: "medium", description: "File reading capability" },
  "CreateFileMapping": { type: "rat", severity: "high", description: "Memory mapping - code injection" },
  "MapViewOfFile": { type: "rat", severity: "high", description: "Memory view mapping - code injection" },
  "AdjustTokenPrivileges": { type: "backdoor", severity: "high", description: "Privilege escalation attempt" },
  "WriteProcessMemory": { type: "trojan", severity: "critical", description: "Process memory modification - code injection" },
  "OpenProcess": { type: "spyware", severity: "medium", description: "Process access for monitoring or injection" },
  "EnumProcesses": { type: "spyware", severity: "low", description: "Process enumeration" },
  "GetKeyboardState": { type: "keylogger", severity: "high", description: "Keyboard state monitoring" },
  "SetWindowsHookExA": { type: "keylogger", severity: "critical", description: "Global keyboard hook" },
  "ShellExecuteA": { type: "trojan", severity: "high", description: "Command execution" },
  "WinHttpOpen": { type: "spyware", severity: "high", description: "HTTP communication - potential C2" },
  "InternetReadFile": { type: "trojan", severity: "high", description: "Downloading payload from internet" },
  "RegCreateKeyEx": { type: "ransomware", severity: "medium", description: "Registry persistence" },
  "CryptGenKey": { type: "ransomware", severity: "critical", description: "Encryption key generation" },
  "IsDebuggerPresent": { type: "backdoor", severity: "medium", description: "Anti-debugging technique" },
  "CheckRemoteDebuggerPresent": { type: "backdoor", severity: "medium", description: "Anti-analysis technique" },
  "Sleep": { type: "trojan", severity: "low", description: "Delay execution to evade sandboxes" },
};

/**
 * Behavioral patterns that indicate malicious activity
 */
const BEHAVIORAL_PATTERNS: BehaviorIndicator[] = [
  {
    behavior: "Process Injection",
    description: "Attempts to inject code into other processes",
    severity: "critical",
    confidence: 85,
  },
  {
    behavior: "Registry Modification",
    description: "Modifies Windows registry for persistence",
    severity: "high",
    confidence: 80,
  },
  {
    behavior: "File Encryption",
    description: "Encrypts files on the system",
    severity: "critical",
    confidence: 90,
  },
  {
    behavior: "Network Communication",
    description: "Establishes network connections for C&C communication",
    severity: "high",
    confidence: 75,
  },
  {
    behavior: "Privilege Escalation",
    description: "Attempts to elevate privileges",
    severity: "high",
    confidence: 80,
  },
  {
    behavior: "Persistence Mechanism",
    description: "Installs persistence for automatic execution",
    severity: "high",
    confidence: 85,
  },
  {
    behavior: "Anti-Analysis",
    description: "Attempts to detect and evade analysis tools",
    severity: "medium",
    confidence: 70,
  },
  {
    behavior: "Lateral Movement",
    description: "Spreads to other systems on the network",
    severity: "high",
    confidence: 80,
  },
];

/**
 * Analyze binary data for malware signatures and patterns
 */
export function analyzeBinary(buffer: Buffer, fileName: string): MalwareAnalysisResult {
  const fileHash = calculateHash(buffer);
  const fileSize = buffer.length;
  
  // Detect suspicious patterns
  const suspiciousPatterns = detectPatterns(buffer, fileName);
  
  // Detect threats based on patterns
  const detectedThreats = detectThreats(suspiciousPatterns);
  
  // Analyze behavioral indicators
  const behaviorAnalysis = analyzeBehavior(suspiciousPatterns, detectedThreats);
  
  // Calculate risk score
  const riskScore = calculateRiskScore(suspiciousPatterns, detectedThreats, behaviorAnalysis);
  
  // Determine threat level
  const threatLevel = determineThreatLevel(riskScore);
  
  // Generate summary
  const summary = generateSummary(suspiciousPatterns, detectedThreats, threatLevel);
  
  return {
    fileHash,
    fileSize,
    suspiciousPatterns,
    detectedThreats,
    behaviorAnalysis,
    threatLevel,
    riskScore,
    summary,
  };
}

/**
 * Calculate SHA-256 hash of buffer
 */
function calculateHash(buffer: Buffer): string {
  return crypto.createHash("sha256").update(buffer).digest("hex");
}

/**
 * Detect suspicious patterns in binary
 */
function detectPatterns(buffer: Buffer, fileName: string): SuspiciousPattern[] {
  const patterns: SuspiciousPattern[] = [];
  const bufferStr = buffer.toString("utf8", 0, Math.min(buffer.length, 100000));
  
  // Check for suspicious file extensions
  const suspiciousExtensions = [".exe", ".dll", ".sys", ".scr", ".vbs", ".bat", ".cmd"];
  const fileExt = fileName.toLowerCase().substring(fileName.lastIndexOf("."));
  
  if (suspiciousExtensions.includes(fileExt)) {
    patterns.push({
      name: "Executable File",
      description: `File has executable extension: ${fileExt}`,
      severity: "high",
      indicator: fileExt,
      confidence: 70,
    });
  }
  
  // Check for known malware signatures
  for (const [signature, info] of Object.entries(MALWARE_SIGNATURES)) {
    if (bufferStr.includes(signature)) {
      patterns.push({
        name: signature,
        description: info.description,
        severity: info.severity,
        indicator: signature,
        confidence: 75 + Math.random() * 20,
      });
    }
  }
  
  // Check for suspicious strings
  const suspiciousStrings = [
    { str: "cmd.exe", desc: "Command shell execution" },
    { str: "powershell", desc: "PowerShell execution" },
    { str: "reg.exe", desc: "Registry modification" },
    { str: "taskkill", desc: "Process termination" },
    { str: "wmic", desc: "WMI command execution" },
    { str: "schtasks", desc: "Scheduled task creation" },
    { str: "net.exe", desc: "Network command execution" },
    { str: "ipconfig", desc: "Network reconnaissance" },
    { str: "nslookup", desc: "DNS resolution" },
    { str: "ping", desc: "Network connectivity check" },
  ];
  
  for (const { str, desc } of suspiciousStrings) {
    if (bufferStr.includes(str)) {
      patterns.push({
        name: `Suspicious Command: ${str}`,
        description: desc,
        severity: "medium",
        indicator: str,
        confidence: 60 + Math.random() * 25,
      });
    }
  }
  
  // Check for obfuscation indicators
  const highEntropyRatio = calculateEntropy(buffer) > 7.5;
  if (highEntropyRatio) {
    patterns.push({
      name: "High Entropy Data",
      description: "Binary contains highly compressed or encrypted data - possible obfuscation",
      severity: "medium",
      indicator: "entropy",
      confidence: 65,
    });
  }
  
  return patterns;
}

/**
 * Calculate Shannon entropy of buffer
 */
function calculateEntropy(buffer: Buffer): number {
  const frequencies: Record<number, number> = {};
  
  for (let i = 0; i < Math.min(buffer.length, 10000); i++) {
    const byte = buffer[i];
    frequencies[byte] = (frequencies[byte] || 0) + 1;
  }
  
  let entropy = 0;
  const length = Math.min(buffer.length, 10000);
  
  for (const freq of Object.values(frequencies)) {
    const p = freq / length;
    entropy -= p * Math.log2(p);
  }
  
  return entropy;
}

/**
 * Detect threats based on patterns
 */
function detectThreats(patterns: SuspiciousPattern[]): DetectedThreat[] {
  const threats: DetectedThreat[] = [];
  const threatMap: Record<ThreatType, number> = {
    virus: 0,
    spyware: 0,
    rat: 0,
    trojan: 0,
    ransomware: 0,
    worm: 0,
    backdoor: 0,
    adware: 0,
    rootkit: 0,
    keylogger: 0,
  };
  
  // Count threat indicators
  for (const pattern of patterns) {
    const signature = MALWARE_SIGNATURES[pattern.indicator];
    if (signature) {
      threatMap[signature.type] += pattern.confidence;
    }
  }
  
  // Generate threat list
  for (const [threatType, score] of Object.entries(threatMap)) {
    if (score > 50) {
      threats.push({
        type: threatType as ThreatType,
        confidence: Math.min(score / patterns.length, 100),
        description: `Detected indicators of ${threatType} activity`,
        location: "Binary analysis",
      });
    }
  }
  
  return threats.sort((a, b) => b.confidence - a.confidence);
}

/**
 * Analyze behavioral indicators
 */
function analyzeBehavior(
  patterns: SuspiciousPattern[],
  threats: DetectedThreat[]
): BehaviorIndicator[] {
  const behaviors: BehaviorIndicator[] = [];
  
  // If we detected certain threats, add relevant behaviors
  if (threats.some((t) => t.type === "rat" || t.type === "backdoor")) {
    behaviors.push(BEHAVIORAL_PATTERNS[0]); // Process Injection
    behaviors.push(BEHAVIORAL_PATTERNS[5]); // Persistence Mechanism
  }
  
  if (threats.some((t) => t.type === "ransomware")) {
    behaviors.push(BEHAVIORAL_PATTERNS[2]); // File Encryption
    behaviors.push(BEHAVIORAL_PATTERNS[1]); // Registry Modification
  }
  
  if (threats.some((t) => t.type === "spyware" || t.type === "keylogger")) {
    behaviors.push(BEHAVIORAL_PATTERNS[3]); // Network Communication
  }
  
  if (threats.some((t) => t.type === "worm")) {
    behaviors.push(BEHAVIORAL_PATTERNS[7]); // Lateral Movement
  }
  
  if (patterns.some((p) => p.indicator === "entropy")) {
    behaviors.push(BEHAVIORAL_PATTERNS[6]); // Anti-Analysis
  }
  
  return behaviors;
}

/**
 * Calculate overall risk score
 */
function calculateRiskScore(
  patterns: SuspiciousPattern[],
  threats: DetectedThreat[],
  behaviors: BehaviorIndicator[]
): number {
  let score = 0;
  
  // Pattern score (40% weight)
  if (patterns.length > 0) {
    const avgPatternConfidence = patterns.reduce((sum, p) => sum + p.confidence, 0) / patterns.length;
    const patternSeverityScore = patterns.reduce((sum, p) => {
      const severityWeight = { low: 10, medium: 30, high: 60, critical: 90 };
      return sum + severityWeight[p.severity];
    }, 0) / patterns.length;
    score += (avgPatternConfidence * 0.3 + patternSeverityScore * 0.7) * 0.4;
  }
  
  // Threat score (40% weight)
  if (threats.length > 0) {
    const avgThreatConfidence = threats.reduce((sum, t) => sum + t.confidence, 0) / threats.length;
    score += avgThreatConfidence * 0.4;
  }
  
  // Behavior score (20% weight)
  if (behaviors.length > 0) {
    const avgBehaviorConfidence = behaviors.reduce((sum, b) => sum + b.confidence, 0) / behaviors.length;
    const behaviorSeverityScore = behaviors.reduce((sum, b) => {
      const severityWeight = { low: 10, medium: 30, high: 60, critical: 90 };
      return sum + severityWeight[b.severity];
    }, 0) / behaviors.length;
    score += (avgBehaviorConfidence * 0.3 + behaviorSeverityScore * 0.7) * 0.2;
  }
  
  return Math.min(Math.round(score), 100);
}

/**
 * Determine threat level based on risk score
 */
function determineThreatLevel(riskScore: number): ThreatLevel {
  if (riskScore < 20) return "clean";
  if (riskScore < 50) return "suspicious";
  if (riskScore < 80) return "malicious";
  return "critical";
}

/**
 * Generate summary of findings
 */
function generateSummary(
  patterns: SuspiciousPattern[],
  threats: DetectedThreat[],
  threatLevel: ThreatLevel
): string {
  if (threatLevel === "clean") {
    return "No significant threats detected. File appears to be safe.";
  }
  
  const threatTypes = threats.map((t) => t.type).join(", ");
  const patternCount = patterns.length;
  
  let summary = `This file exhibits characteristics of ${threatLevel} malware. `;
  
  if (threats.length > 0) {
    summary += `Detected threat types: ${threatTypes}. `;
  }
  
  summary += `Found ${patternCount} suspicious pattern(s). `;
  
  if (threatLevel === "critical") {
    summary += "IMMEDIATE ACTION RECOMMENDED: Do not execute this file.";
  } else if (threatLevel === "malicious") {
    summary += "HIGH RISK: This file should be quarantined and analyzed further.";
  } else if (threatLevel === "suspicious") {
    summary += "CAUTION: This file shows signs of suspicious activity and should be investigated.";
  }
  
  return summary;
}
